import pandas as pd
from fbprophet import Prophet

def cv_cutoffs(last_timestamp, steps, future_horizon, step_size):
    """
    Returns a list with the cutoff dates,
    calculated backwards since last_date.

    Parameters
    ----------
    last_timestamp : pd.Timestamp
        Last validation day.

    steps : int
        Number of folds.

    future_horizon : pd.Timedelta
        Future horizon of every fold.

    step_size : pd.Timedelta
        Distance between cutoffs.

    Returns
    -------
    cutoffs: list
        List containing cutoff dates
    """
    cutoffs = []
    cutoff = last_timestamp

    for step in range(steps):
        if step == 0:
            cutoff -= future_horizon
        else:
            cutoff -= step_size

        cutoffs.append(cutoff)

    return list(reversed(cutoffs))



def cv_cutoffs_v2(first_val_day, steps, step_size):
    """
    Returns a list with the cutoff dates,
    calculated forwards since last_date.

    Parameters
    ----------
    first_val_day : pd.Timestamp
        First validation day

    steps : int
        Number of folds.

    step_size : pd.Timedelta
        Distance between cutoffs.


    Returns
    -------
    cutoffs: list
        List containing cutoff dates
    """
    cutoffs = [first_val_day]
    cutoff = first_val_day

    for step in range(steps - 1):
        cutoff += step_size
        cutoffs.append(cutoff)

    return cutoffs

def cv_generator(data, cutoffs, future_horizon):
    """
    Returns a generator that returns train
    and validation dataframes for each cutoff.

    Parameters
    ----------
    data : pd.DataFrame
        A DatetimeIndex index is expected.

    cutoffs : iterable of datetime.datetime or pd.Timestamp
        Cutoff dates

    freq: string
        Frequency strings

    future_horizon : pd.Timedelta
        Future horizon of every fold.

    Returns
    -------
    generator
    """

    for cutoff in cutoffs:

        train_df = data[:cutoff]
        val_df = data[cutoff:cutoff + future_horizon]

        yield (cutoff, train_df, val_df)

def prophet_cv_results(cv_generator, verbose = 0, **kwargs):
    """
    Returns a backtesting results using Prophet.

    Parameters
    ----------

    cv_generator : generator
        Generator that returns the tuple (cutoff, train_df, val_df)

    Returns
    -------
    pd.DataFrame
    """
    results = []

    for cutoff, train, val in cv_generator:
        df = pd.DataFrame(columns = ['ds','y'])
        df['ds'] = train.index
        df['y'] = train.loc[:,'y'].values

        model = Prophet(**kwargs)
        model.fit(df)

        future = model.make_future_dataframe(periods = len(val), freq = pd.infer_freq(val.index))

        result = pd.DataFrame(columns = ['y','yhat','cutoff'], index = val.index)
        result['y'] = val.loc[:,'y'].values
        result['yhat'] = model.predict(future).loc[:,'yhat'].values[-len(val):]
        result['cutoff'] = cutoff

        results.append(result)

    if verbose > 0:
        print(f'Cutoff: {cutoff} done.')

    return pd.concat(results)

def ts_to_table(data, lags, drop = True):
    """
    Returns a table with target Lags

    Parameters
    ----------

    serie : pd.Series
        Time series target values, a Datetimeindex index is expected

    lags : int
        Lags to consider in the data generation

    drop : bool
        Drops the NaN rows generated by the shifts

    Returns
    -------
    pd.DataFrame
    """
    df = data.copy()

    for lag in range(1, lags+1):
        df[f'lag_{lag}'] = df['y'].shift(lag).values

    if drop:
        df.dropna(inplace = True)

    return df

def sklearn_cv_results(cv_generator, model, lags, drop, verbose = 0):
    """
    Returns a backtesting results using a sklearn model.

    Parameters
    ----------
    cv_generator : generator
        Generator that returns the tuple (cutoff, train_df, val_df)

    regressors : list
        List with regressors name

    model : scikit-learn-like estimator
        Must be an instantiated estimator.

    lags : int
        Lags to consider in the data generation

    drop : bool
        Drops the NaN rows generated by the shifts

    Returns
    -------
    pd.DataFrame
    """
    results = []

    for cutoff, train, val in cv_generator:

        train_tab = ts_to_table(train, lags, drop = drop)
        val_tab = ts_to_table(val, lags, drop = drop)

        model.fit(train_tab.drop('y', axis = 1), train_tab['y'])
        result = pd.DataFrame(columns = ['y','yhat','cutoff'], index = val_tab.index)
        result['y'] = val_tab.loc[:,'y'].values
        result['yhat'] = model.predict(val_tab.drop('y', axis = 1))
        result['cutoff'] = cutoff

        results.append(result)

    if verbose > 0:
        print(f'Cutoff: {cutoff} done.')

    return pd.concat(results)


def backtest_results(execution_date,
                     steps,
                     window_size,
                     step_size,
                     model = None,
                     lags = None,
                     drop = None,
                     verbose = 1,
                     **kwargs):
    """
    Returns a backtesting dataframe result.

    Parameters
    ----------
    execution_date : pd.Timestamp
        Last day of validation.

    steps : int
        Number of folds.

    window_size : pd.Timedelta
        Future horizon of every fold.

    step_size : pd.Timedelta
        Distance between cutoffs.

    model : scikit-learn-like estimator
        Must be an instantiated estimator.

    lags : int
        Lags to consider in the data generation

    drop : bool
        Drops the NaN rows generated by the shifts
    """

    cutoffs = cv_cutoffs(execution_date, steps, window_size, step_size)
    cv = cv_generator(data, cutoffs, window_size)

    if model is not None:
        results = sklearn_cv_results(cv, model = model, lags = lags, drop = True, verbose = verbose)
        return results

    else:
        results = prophet_cv_results(cv, verbose = verbose, **kwargs)
        return results
